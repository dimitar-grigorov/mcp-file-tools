
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>encoding: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/dimitar-grigorov/mcp-file-tools/internal/encoding/detect.go (68.8%)</option>
				
				<option value="file1">github.com/dimitar-grigorov/mcp-file-tools/internal/encoding/registry.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package encoding

import (
        "fmt"
        "io"
        "os"
        "strings"
        "unicode/utf8"

        "github.com/wlynxg/chardet"
)

// Detection constants
const (
        ChunkSize               = 128 * 1024 // 128KB chunks for detection
        SmallFileThreshold      = 128 * 1024 // Files smaller than this are read entirely
        HighConfidenceThreshold = 80         // Confidence level to stop sampling early
        MinConfidenceThreshold  = 50         // Minimum confidence to trust detection
)

// DetectionResult holds encoding detection result.
type DetectionResult struct {
        Charset    string
        Confidence int
        HasBOM     bool
}

// --- Primary API (file-based, streaming) ---

// DetectFromFile detects encoding from a file path using streaming I/O.
// Modes: "sample" (~384KB max), "chunked" (streams entire file), "full" (loads entire file).
func DetectFromFile(path string, mode string) (DetectionResult, error) <span class="cov8" title="1">{
        file, err := os.Open(path)
        if err != nil </span><span class="cov8" title="1">{
                return DetectionResult{}, fmt.Errorf("failed to open file: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        stat, err := file.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return DetectionResult{}, fmt.Errorf("failed to stat file: %w", err)
        }</span>

        <span class="cov8" title="1">return detectFromReader(file, stat.Size(), mode)</span>
}

// Detect detects encoding from a byte slice.
func Detect(data []byte) DetectionResult <span class="cov8" title="1">{
        // Check UTF-8 BOM
        if len(data) &gt;= 3 &amp;&amp; data[0] == 0xEF &amp;&amp; data[1] == 0xBB &amp;&amp; data[2] == 0xBF </span><span class="cov8" title="1">{
                return DetectionResult{Charset: "utf-8", Confidence: 100, HasBOM: true}
        }</span>

        <span class="cov8" title="1">detected := chardet.Detect(data)
        if detected.Encoding == "" </span><span class="cov8" title="1">{
                if utf8.Valid(data) </span><span class="cov8" title="1">{
                        return DetectionResult{Charset: "utf-8", Confidence: 80}
                }</span>
                <span class="cov0" title="0">return DetectionResult{}</span>
        }

        <span class="cov8" title="1">return DetectionResult{
                Charset:    strings.ToLower(detected.Encoding),
                Confidence: int(detected.Confidence * 100),
        }</span>
}

// DetectSample detects encoding by sampling beginning, middle, and end of data.
// Returns the result and whether it should be trusted.
// TODO: Make private or remove when grep.go and convert_encoding.go use streaming I/O.
func DetectSample(data []byte) (DetectionResult, bool) <span class="cov8" title="1">{
        size := len(data)

        if size &lt;= SmallFileThreshold </span><span class="cov8" title="1">{
                result := Detect(data)
                return result, result.Confidence &gt;= MinConfidenceThreshold
        }</span>

        // Sample chunks from beginning, middle, and end
        <span class="cov8" title="1">var samples []byte

        // Beginning chunk
        endOfFirst := min(ChunkSize, size)
        samples = append(samples, data[:endOfFirst]...)

        // Check beginning first - if high confidence, return early
        result := Detect(samples)
        if result.Confidence &gt;= HighConfidenceThreshold </span><span class="cov8" title="1">{
                return result, true
        }</span>

        // Middle chunk
        <span class="cov0" title="0">if size &gt; ChunkSize*2 </span><span class="cov0" title="0">{
                midStart := (size - ChunkSize) / 2
                midEnd := min(midStart+ChunkSize, size)
                samples = append(samples, data[midStart:midEnd]...)
        }</span>

        // End chunk
        <span class="cov0" title="0">if size &gt; ChunkSize </span><span class="cov0" title="0">{
                endStart := max(0, size-ChunkSize)
                samples = append(samples, data[endStart:]...)
        }</span>

        <span class="cov0" title="0">result = Detect(samples)
        return result, result.Confidence &gt;= MinConfidenceThreshold</span>
}

// --- Internal streaming implementation ---

func detectFromReader(r io.ReaderAt, size int64, mode string) (DetectionResult, error) <span class="cov8" title="1">{
        switch mode </span>{
        case "sample":<span class="cov8" title="1">
                return detectSampleFromReader(r, size)</span>
        case "chunked":<span class="cov8" title="1">
                return detectChunkedFromReader(r, size)</span>
        case "full":<span class="cov8" title="1">
                return detectFullFromReader(r, size)</span>
        default:<span class="cov8" title="1">
                return DetectionResult{}, fmt.Errorf("invalid mode: %s (valid: sample, chunked, full)", mode)</span>
        }
}

func detectSampleFromReader(r io.ReaderAt, size int64) (DetectionResult, error) <span class="cov8" title="1">{
        if size &lt;= SmallFileThreshold </span><span class="cov8" title="1">{
                data := make([]byte, size)
                if _, err := r.ReadAt(data, 0); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        return DetectionResult{}, fmt.Errorf("failed to read file: %w", err)
                }</span>
                <span class="cov8" title="1">return Detect(data), nil</span>
        }

        // Read beginning chunk
        <span class="cov8" title="1">beginChunk := make([]byte, ChunkSize)
        n, err := r.ReadAt(beginChunk, 0)
        if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return DetectionResult{}, fmt.Errorf("failed to read beginning: %w", err)
        }</span>
        <span class="cov8" title="1">beginChunk = beginChunk[:n]

        // Check for BOM
        if len(beginChunk) &gt;= 3 &amp;&amp; beginChunk[0] == 0xEF &amp;&amp; beginChunk[1] == 0xBB &amp;&amp; beginChunk[2] == 0xBF </span><span class="cov8" title="1">{
                return DetectionResult{Charset: "utf-8", Confidence: 100, HasBOM: true}, nil
        }</span>

        // Check beginning chunk - if high confidence, return early
        <span class="cov8" title="1">result := Detect(beginChunk)
        if result.Confidence &gt;= HighConfidenceThreshold </span><span class="cov8" title="1">{
                return result, nil
        }</span>

        // Collect samples for combined detection
        <span class="cov0" title="0">samples := make([]byte, 0, ChunkSize*3)
        samples = append(samples, beginChunk...)

        // Middle chunk
        if size &gt; int64(ChunkSize*2) </span><span class="cov0" title="0">{
                midStart := (size - int64(ChunkSize)) / 2
                midChunk := make([]byte, ChunkSize)
                n, err := r.ReadAt(midChunk, midStart)
                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        return DetectionResult{}, fmt.Errorf("failed to read middle: %w", err)
                }</span>
                <span class="cov0" title="0">samples = append(samples, midChunk[:n]...)</span>
        }

        // End chunk
        <span class="cov0" title="0">if size &gt; int64(ChunkSize) </span><span class="cov0" title="0">{
                endStart := size - int64(ChunkSize)
                endChunk := make([]byte, ChunkSize)
                n, err := r.ReadAt(endChunk, endStart)
                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        return DetectionResult{}, fmt.Errorf("failed to read end: %w", err)
                }</span>
                <span class="cov0" title="0">samples = append(samples, endChunk[:n]...)</span>
        }

        <span class="cov0" title="0">return Detect(samples), nil</span>
}

func detectChunkedFromReader(r io.ReaderAt, size int64) (DetectionResult, error) <span class="cov8" title="1">{
        if size &lt;= int64(ChunkSize) </span><span class="cov8" title="1">{
                data := make([]byte, size)
                if _, err := r.ReadAt(data, 0); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        return DetectionResult{}, fmt.Errorf("failed to read file: %w", err)
                }</span>
                <span class="cov8" title="1">return Detect(data), nil</span>
        }

        // Check for BOM
        <span class="cov8" title="1">bomCheck := make([]byte, 3)
        if n, _ := r.ReadAt(bomCheck, 0); n &gt;= 3 </span><span class="cov8" title="1">{
                if bomCheck[0] == 0xEF &amp;&amp; bomCheck[1] == 0xBB &amp;&amp; bomCheck[2] == 0xBF </span><span class="cov8" title="1">{
                        return DetectionResult{Charset: "utf-8", Confidence: 100, HasBOM: true}, nil
                }</span>
        }

        // Process file in chunks
        <span class="cov8" title="1">type chunkResult struct {
                encoding   string
                confidence int
                weight     int
        }

        var results []chunkResult
        chunk := make([]byte, ChunkSize)

        for offset := int64(0); offset &lt; size; </span><span class="cov8" title="1">{
                n, err := r.ReadAt(chunk, offset)
                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        return DetectionResult{}, fmt.Errorf("failed to read chunk at %d: %w", offset, err)
                }</span>
                <span class="cov8" title="1">if n == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">detected := Detect(chunk[:n])
                if detected.Charset != "" </span><span class="cov8" title="1">{
                        results = append(results, chunkResult{
                                encoding:   detected.Charset,
                                confidence: detected.Confidence,
                                weight:     n,
                        })
                }</span>
                <span class="cov8" title="1">offset += int64(n)</span>
        }

        <span class="cov8" title="1">if len(results) == 0 </span><span class="cov0" title="0">{
                return DetectionResult{}, nil
        }</span>

        // Aggregate results with weighted confidence
        <span class="cov8" title="1">encodingWeights := make(map[string]int)
        encodingConfidenceSum := make(map[string]int)

        for _, r := range results </span><span class="cov8" title="1">{
                encodingWeights[r.encoding] += r.weight
                encodingConfidenceSum[r.encoding] += r.confidence * r.weight
        }</span>

        <span class="cov8" title="1">var bestEncoding string
        var bestWeight int
        for enc, weight := range encodingWeights </span><span class="cov8" title="1">{
                if weight &gt; bestWeight </span><span class="cov8" title="1">{
                        bestWeight = weight
                        bestEncoding = enc
                }</span>
        }

        <span class="cov8" title="1">return DetectionResult{
                Charset:    bestEncoding,
                Confidence: encodingConfidenceSum[bestEncoding] / encodingWeights[bestEncoding],
        }, nil</span>
}

func detectFullFromReader(r io.ReaderAt, size int64) (DetectionResult, error) <span class="cov8" title="1">{
        data := make([]byte, size)
        if _, err := r.ReadAt(data, 0); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return DetectionResult{}, fmt.Errorf("failed to read file: %w", err)
        }</span>
        <span class="cov8" title="1">return Detect(data), nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package encoding

import (
        "sort"
        "strings"

        "golang.org/x/text/encoding"
        "golang.org/x/text/encoding/charmap"
)

// EncodingInfo holds metadata about a supported encoding.
type EncodingInfo struct {
        Encoding    encoding.Encoding // nil means UTF-8 passthrough
        DisplayName string
        Aliases     []string
        Description string
}

// encodings defines all supported encodings with their metadata.
// The key is the canonical (primary) name.
var encodings = map[string]EncodingInfo{
        // UTF-8 (passthrough - no conversion needed)
        "utf-8": {
                Encoding:    nil,
                DisplayName: "UTF-8",
                Aliases:     []string{"utf8", "ascii"},
                Description: "Unicode, no conversion",
        },

        // Cyrillic encodings
        "windows-1251": {
                Encoding:    charmap.Windows1251,
                DisplayName: "Windows-1251",
                Aliases:     []string{"cp1251"},
                Description: "Windows Cyrillic",
        },
        "koi8-r": {
                Encoding:    charmap.KOI8R,
                DisplayName: "KOI8-R",
                Aliases:     []string{"koi8r"},
                Description: "Russian Cyrillic (Unix/Linux)",
        },
        "koi8-u": {
                Encoding:    charmap.KOI8U,
                DisplayName: "KOI8-U",
                Aliases:     []string{"koi8u"},
                Description: "Ukrainian Cyrillic (Unix/Linux)",
        },
        "ibm866": {
                Encoding:    charmap.CodePage866,
                DisplayName: "CP866",
                Aliases:     []string{"cp866", "dos-866"},
                Description: "DOS Cyrillic",
        },
        "iso-8859-5": {
                Encoding:    charmap.ISO8859_5,
                DisplayName: "ISO-8859-5",
                Aliases:     []string{"iso88595", "cyrillic"},
                Description: "ISO Cyrillic",
        },

        // Western European encodings
        "windows-1252": {
                Encoding:    charmap.Windows1252,
                DisplayName: "Windows-1252",
                Aliases:     []string{"cp1252"},
                Description: "Windows Western European",
        },
        "iso-8859-1": {
                Encoding:    charmap.ISO8859_1,
                DisplayName: "ISO-8859-1",
                Aliases:     []string{"iso88591", "latin1"},
                Description: "Latin-1 Western European",
        },
        "iso-8859-15": {
                Encoding:    charmap.ISO8859_15,
                DisplayName: "ISO-8859-15",
                Aliases:     []string{"iso885915", "latin9"},
                Description: "Latin-9 Western European (Euro)",
        },

        // Central European encodings
        "windows-1250": {
                Encoding:    charmap.Windows1250,
                DisplayName: "Windows-1250",
                Aliases:     []string{"cp1250"},
                Description: "Windows Central European",
        },
        "iso-8859-2": {
                Encoding:    charmap.ISO8859_2,
                DisplayName: "ISO-8859-2",
                Aliases:     []string{"iso88592", "latin2"},
                Description: "Latin-2 Central European",
        },

        // Greek
        "windows-1253": {
                Encoding:    charmap.Windows1253,
                DisplayName: "Windows-1253",
                Aliases:     []string{"cp1253"},
                Description: "Windows Greek",
        },
        "iso-8859-7": {
                Encoding:    charmap.ISO8859_7,
                DisplayName: "ISO-8859-7",
                Aliases:     []string{"iso88597", "greek"},
                Description: "ISO Greek",
        },

        // Turkish
        "windows-1254": {
                Encoding:    charmap.Windows1254,
                DisplayName: "Windows-1254",
                Aliases:     []string{"cp1254"},
                Description: "Windows Turkish",
        },
        "iso-8859-9": {
                Encoding:    charmap.ISO8859_9,
                DisplayName: "ISO-8859-9",
                Aliases:     []string{"iso88599", "latin5"},
                Description: "Latin-5 Turkish",
        },

        // Hebrew
        "windows-1255": {
                Encoding:    charmap.Windows1255,
                DisplayName: "Windows-1255",
                Aliases:     []string{"cp1255"},
                Description: "Windows Hebrew",
        },

        // Arabic
        "windows-1256": {
                Encoding:    charmap.Windows1256,
                DisplayName: "Windows-1256",
                Aliases:     []string{"cp1256"},
                Description: "Windows Arabic",
        },

        // Baltic
        "windows-1257": {
                Encoding:    charmap.Windows1257,
                DisplayName: "Windows-1257",
                Aliases:     []string{"cp1257"},
                Description: "Windows Baltic",
        },

        // Vietnamese
        "windows-1258": {
                Encoding:    charmap.Windows1258,
                DisplayName: "Windows-1258",
                Aliases:     []string{"cp1258"},
                Description: "Windows Vietnamese",
        },

        // Thai
        "windows-874": {
                Encoding:    charmap.Windows874,
                DisplayName: "Windows-874",
                Aliases:     []string{"cp874", "tis-620"},
                Description: "Windows Thai",
        },
}

// registry is the fast lookup map built from encodings.
// Maps all names (canonical + aliases) to their EncodingInfo.
var registry map[string]*EncodingInfo

func init() <span class="cov8" title="1">{
        registry = make(map[string]*EncodingInfo)

        for canonical, info := range encodings </span><span class="cov8" title="1">{
                infoCopy := info // Create a copy to get a stable pointer
                registry[canonical] = &amp;infoCopy

                for _, alias := range info.Aliases </span><span class="cov8" title="1">{
                        registry[alias] = &amp;infoCopy
                }</span>
        }
}

// Get returns the encoding for the given name.
func Get(name string) (encoding.Encoding, bool) <span class="cov8" title="1">{
        info, ok := registry[strings.ToLower(name)]
        if !ok </span><span class="cov8" title="1">{
                return nil, false
        }</span>
        <span class="cov8" title="1">return info.Encoding, true</span>
}

// IsUTF8 checks if the encoding name refers to UTF-8.
func IsUTF8(name string) bool <span class="cov8" title="1">{
        lower := strings.ToLower(name)
        return lower == "utf-8" || lower == "utf8" || lower == "ascii"
}</span>

// EncodingListItem represents an encoding in the list output.
type EncodingListItem struct {
        Name        string   `json:"name"`
        DisplayName string   `json:"displayName"`
        Aliases     []string `json:"aliases"`
        Description string   `json:"description"`
}

// ListEncodings returns a structured list of all supported encodings.
func ListEncodings() []EncodingListItem <span class="cov8" title="1">{
        var items []EncodingListItem

        for canonical, info := range encodings </span><span class="cov8" title="1">{
                items = append(items, EncodingListItem{
                        Name:        canonical,
                        DisplayName: info.DisplayName,
                        Aliases:     info.Aliases,
                        Description: info.Description,
                })
        }</span>

        // Sort by display name for consistent output
        <span class="cov8" title="1">sort.Slice(items, func(i, j int) bool </span><span class="cov8" title="1">{
                return items[i].DisplayName &lt; items[j].DisplayName
        }</span>)

        <span class="cov8" title="1">return items</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
